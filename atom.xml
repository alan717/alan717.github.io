<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>探索,进取,坚持</title><link href="alan717.github.io/" rel="alternate"></link><link href="alan717.github.io/atom.xml" rel="self"></link><id>alan717.github.io/</id><updated>2023-08-25T00:00:00+08:00</updated><subtitle>LK's blog</subtitle><entry><title>SHINEY650摩托车改装</title><link href="alan717.github.io/motorcycle.html" rel="alternate"></link><published>2023-08-25T00:00:00+08:00</published><updated>2023-08-25T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2023-08-25:alan717.github.io/motorcycle.html</id><summary type="html">折腾SHINEY650摩托车的过程</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;8月购买了鑫源650摩托。&lt;/p&gt;
&lt;h3&gt;spec&lt;/h3&gt;
&lt;p&gt;| sepc            | value                  | 品牌            |&lt;br&gt;
|-----------------|------------------------|---------------|
| 发动机             | 单缸四冲程 油冷·650cc         |               |
| 发动机型号           | 1100YMT                |               |
| 排量：             | 650                    |               |
| 精确排量cc:         | 644                    |               |
| 缸径x行程(mm)：      | 100x82                 |               |
| 发动机冲程           | 四冲程                    |               |
| 压缩比             | 8.3:1                  |               |
| 冷却方式            | 油冷                     |               |
| 马力Ps            | 40.8                   |               |
| 最大功率            | 30                     |               |
| 最大功率转速(rpm)     | 6000                   |               |
| 最大扭矩            | 50                     |               |
| 最大扭矩转速          | 5000                   |               |
| 供油方式            | 电喷                     |               |
| 官方平均油耗(L/100km) | 4.5                    |               |
| 变速器             | 国际5档                   |               |
| 离合器             | 湿式多片离合                 |               |
| 前轮规格            | 100/90-19              | 建大            |
| 后轮规格            | 130/80-18              |               |
| 轮胎形式            | 真空胎                    |               |
| 轮辋              | 钢制辐条式                  |               |
| 前制动系统           | 320mm单碟对置四活塞卡钳         |               |
| 后制动系统           | 240mm单碟双活塞卡钳           |               |
| 前后灯             | led                    |               |
| 转向灯             | 卤素                     |               |
| ABS防抱死系统        | 标配前后                   |               |
| 油门配置            | 单拉线油门                  |               |
| 干重(kg)          | 173                    |               |
| 整备质量(kg)        | 183                    |               |
| 前倾角度(°)         | 28                     |               |
| 最小转弯半径(m)       | 2.45                   |               |
| 最大有效载荷(kg)      | 333                    |               |
| 前悬挂系统           | φ41mm双正置液压弹簧减震,行程110mm |               |
| 后悬挂系统           | φ62mm双液压弹簧复合减震,行程50mm  |               |
| 最小离地间隙(mm)      | 160                    |               |
| 轴距(mm)          | 1420                   |               |
| 座高(mm)          | 800                    |               |
| 高度(mm)          | 1150                   |               |
| 宽度(mm)          | 790                    |               |
| 长度(mm)          | 2110                   |               |&lt;/p&gt;
&lt;h2&gt;改装&lt;/h2&gt;
&lt;h3&gt;问题点：引擎运行不平顺，有感觉供油不足的情况&lt;/h3&gt;
&lt;p&gt;初步分析是引擎ecu 程序处理进气和喷油问题，需要分析ECU.&lt;/p&gt;
&lt;h4&gt;ECU&lt;/h4&gt;
&lt;p&gt;购买了同型号ECU，拆解ECU，并尝试PC通信，焊接JTAG管脚供电，然后dump binary程序。
分析中.... 待后续更新。&lt;/p&gt;</content></entry><entry><title>安捷伦衍射仪分析</title><link href="alan717.github.io/anjielun.html" rel="alternate"></link><published>2022-11-23T00:00:00+08:00</published><updated>2022-11-23T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2022-11-23:alan717.github.io/anjielun.html</id><summary type="html">一个安捷伦衍射仪的分析</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;接触了一个实验室的安捷伦衍射仪的分析
全称是:&lt;code&gt;6230B 飞行时间 (TOF) 液质联用系统&lt;/code&gt;
这个衍射仪还很火，看到很多学校的实验室都有这个设备原名tofserver
这个设备情况比较简单，pc104通过高速plx连接fpga和dsp通过pcie和dsp的高速io直接访问获取数据。整体使用的是slackware linux 2.6的系统，也是ko实现高速
dma操作，整体的系统功能解耦设计很棒，代码符号在设备中也有存根。重点在于他的高速io直接通信效率特别高。可以自己进行二次开发。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;解决好的原因是 排查了系统的启动问题和内存memory corruption问题发现tofserver在分配内存malloc时候使用的大小为0 ，这个0是来自于dsp直接在dma  中
存放的数据大小。由此直接上机测试。问题找到解决。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;slackware linux 第一次接触，古老稳健的linux发行版。挺有意思。这种高速采集设备都是通过fpga和dsp实现的图形设别算法获取针对测量值。&lt;/p&gt;</content></entry><entry><title>GO1.21.5分析</title><link href="alan717.github.io/go_re.html" rel="alternate"></link><published>2022-08-13T00:00:00+08:00</published><updated>2022-08-13T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2022-08-13:alan717.github.io/go_re.html</id><summary type="html">go逆向</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;版本是1.21.5 最新
window10&lt;/p&gt;
&lt;h2&gt;pre&lt;/h2&gt;
&lt;p&gt;go编译出来是native代码，所以之间看原生函数吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:
由于是二进制的形式，这里go的数据类型识别，如字符串 数据，数据结构都不是重点。
在此不再过多描述，显得冗余。只关系具体的数据流和算法实现表现，和函数flow。&lt;/p&gt;
&lt;p&gt;最主要的入口是&lt;code&gt;runtime_main&lt;/code&gt; 
在go执行时候首先进行的运行时初始化，判断当前包时lib还是执行程序，有没有进行功能性的函数hook，
这些代码是编译器模板化的代码， 这部分可以对照go的编译器源码生成的函数具体对待。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的分析来看，具体的分析切入点是什么，是分析一个网络程序还是分析追踪一个算法模块。这很重要。&lt;/p&gt;
&lt;h2&gt;难点&lt;/h2&gt;
&lt;h3&gt;难点一 ：符号&lt;/h3&gt;
&lt;p&gt;一般发布的go默认带符号，别人的程序会不带符号
不带符号就是编译时候直接编译器添加ld flag：  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-ldflags=&amp;quot;-s -w&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果如图：&lt;br&gt;
before&lt;br&gt;
&lt;img alt="" src="./img/go1.png"&gt;
after&lt;br&gt;
&lt;img alt="" src="./img/go2.png"&gt;&lt;/p&gt;
&lt;p&gt;这部分可用diff binary实现识别。&lt;/p&gt;
&lt;h3&gt;难点二：加二进制壳&lt;/h3&gt;
&lt;p&gt;常见的二进制壳：upx 等变种
此类壳主要是找到函数entry point.关键找到函数入口，需要动态调试和多次加载识别。&lt;/p&gt;
&lt;h3&gt;难度三：函数复杂性&lt;/h3&gt;
&lt;p&gt;函数的复杂性在于指令流和go编译器的自修改。 通常是通过修改go编译器来加入垃圾指令特殊原语。&lt;br&gt;
这类分析主要是找到关键函数进行回溯数据，回溯栈，难点在于追踪，需要经验和时间。
其中还包括语言特性（反射实现，协程实现，伸缩栈，延迟执行defer，调用约定，cgo）&lt;/p&gt;
&lt;h3&gt;难度四：数据结构复杂度&lt;/h3&gt;
&lt;p&gt;在go中的切片 数组结构体，字典都有自定义的数据结构需要来识别。在没有魔改的情况下，直接对照源码可以分析，如果进行了魔改就要凭借经验来识别并进行分析处理。&lt;/p&gt;
&lt;h4&gt;string&lt;/h4&gt;
&lt;p&gt;go的字符不像arm那样直接存储，因为是强类型，所以是直接存在字符表中类似于elf的字符表，然后根据长度和offset来加载，在追踪时候和别的不同，需要注意。&lt;/p&gt;</content></entry><entry><title>一款日本CPU的分析</title><link href="alan717.github.io/cpu00.html" rel="alternate"></link><published>2021-08-11T00:00:00+08:00</published><updated>2021-08-11T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2021-08-11:alan717.github.io/cpu00.html</id><summary type="html">朋友给了一个cpu需要分析一下程序.</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;朋友做维修，找我分析一个cpu
&lt;img alt="" src="img/cpu00.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如图型号是：&lt;code&gt;D70F3453GC JAPAN 1218KP421&lt;/code&gt;
通过检索大概判定是nec的一个芯片。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这个芯片大概看了,是V850E指令集的芯片，日本瑞萨的，分析起来不费什么工作。
主要找到这个cpu的ds手册，但是没有sdk和pg手册，所以正向的分析使用是不可取的了。 
因为芯片里边有rom flash 存储，这使得代码不容易获取（已经攻击另说）
根据手册相同的cpu指令和型号类型能够获取同型号的设备的文档和代码，作为突破口，确保boot code执行的入口没有问题，然后进行初始化其它设备，整个分析的情况下是在黑盒子的情况进行的&lt;/p&gt;
&lt;p&gt;主要就是猜，目的是同型号推断出此型号的设备信息。然后逐步追踪获取self-programming指令，和串口编程，当然有了他的指令集，剩下的编译部分就容易多了，不是什么&lt;/p&gt;
&lt;p&gt;棘手问题，直接推就完事了。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;只是给我分享了照片，还没有空取他哪里拿设备。设备拿来之后再进行分析。手册在这里&lt;a href="misc/UPD70F3451GC-UBT-A.PDF"&gt;&lt;/a&gt;.&lt;/p&gt;</content></entry><entry><title>Bruker质谱仪分析</title><link href="alan717.github.io/bruker.html" rel="alternate"></link><published>2021-04-23T00:00:00+08:00</published><updated>2021-04-23T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2021-04-23:alan717.github.io/bruker.html</id><summary type="html">A brief description of bruker device.</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;偶然去一个实验室看到这个设备。
设备&lt;code&gt;D8 VENTURE&lt;/code&gt;：&lt;code&gt;SINGLE CRYSTAL X-RAY DIFFRACTION (SC-XRD)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;系统使用了rtlinux内核加iram的initrd作为rootfs，和各个模块全部分装成ko形式来访问管理，设备的初始化全部使用rc来管理。
整个系统直接被剪裁成最小化的形式。然后各个文件系统是根据需要然后loop挂在到关键目录然后进行访问。
整个磁盘无法直接看到内核文件，这是不挂在内核到文件系统下， 整个系统盘要进行dd 然后找到偏移定位内核位置。整体通过网口还要进行一次ssh的访问，具体的访问&lt;/p&gt;
&lt;p&gt;要在整机之下进行调试分析。时间有限，暂时没有这么操作，大概看了一下衍射传感器和系统的连接直接fpga高速直连，然后通过pcie直接驱动。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;驱动的设计和通信方式基本通过ko驱动在文件系统中已经摸清楚，因为自己没有这方面的研究所以没在这个上边投入时间了。文件系统我保存了一份。&lt;/p&gt;</content></entry><entry><title>op7p分析一</title><link href="alan717.github.io/Oneplus7p.html" rel="alternate"></link><published>2020-10-05T00:00:00+08:00</published><updated>2020-10-05T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-10-05:alan717.github.io/Oneplus7p.html</id><summary type="html">分析oneplus7p 引导.</summary><content type="html">&lt;h3&gt;下载固件&lt;/h3&gt;
&lt;p&gt;根据手机的固件版本信息，在大侠阿木下载站下载固件，解包得到payload.bin，然后dump payload.bin得到bootloader abl.img文件，使用imgtool解包
提取linuxloader文件。&lt;/p&gt;
&lt;h3&gt;分析linuxloader文件&lt;/h3&gt;
&lt;p&gt;根据加载时候出现的调试信息
“/work/home/jenkins/18821_STABLE_R_HYDROGEN_MP/AP/SM8150/android/out/target/product/msmnile/obj/ABL_OBJ/Build/DEBUG_CLANG35/AARCH64/QcomModulePkg/Application/LinuxLoader/LinuxLoader/DEBUG/LinuxLoader.dl”
知道这是高通的linuxloader。&lt;/p&gt;
&lt;h3&gt;下载linuxloader&lt;/h3&gt;
&lt;p&gt;https://git.codelinaro.org/clo/le/abl/tianocore/edk2/-/blob/clo/main/QcomModulePkg/Application/LinuxLoader/LinuxLoader.c
这里得到对应的函数。&lt;/p&gt;</content></entry><entry><title>https过程</title><link href="alan717.github.io/tls1_2.html" rel="alternate"></link><published>2020-10-05T00:00:00+08:00</published><updated>2020-10-05T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-10-05:alan717.github.io/tls1_2.html</id><summary type="html">分析https通信及抓包详情</summary><content type="html">&lt;h2&gt;HTTPS 大概过程&lt;/h2&gt;
&lt;p&gt;其中分析具体点看wireshark抓包比较详细的数据结构。
大致过程如下:
1. 客户端发送一个消息中同时包含生成的一个 48 字节的预备主密钥，其中前 2 个字节是 ProtocolVersion，后 46 字节是随机数,
 用 Server 的公钥加密之后通过 Client Key Exchange 子消息发给 Server
2. &lt;/p&gt;</content></entry><entry><title>windows本地监听和转发</title><link href="alan717.github.io/%E6%9C%AC%E5%9C%B0%E7%9B%91%E5%90%AC%E5%92%8C%E8%BD%AC%E5%8F%91.html" rel="alternate"></link><published>2020-09-20T00:00:00+08:00</published><updated>2020-09-20T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-09-20:alan717.github.io/%E6%9C%AC%E5%9C%B0%E7%9B%91%E5%90%AC%E5%92%8C%E8%BD%AC%E5%8F%91.html</id><summary type="html">sockets</summary><content type="html">&lt;h2&gt;env:&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Edition Windows 10 Pro
Version 22H2
Installed on    ‎5/‎7/‎2021
OS build    19045.3324
Experience  Windows Feature Experience Pack 1000.19041.1000.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;方法1：本地和监听转发使用powershell&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;powershell.exe -executionpolicy bypass -file .\Script.ps1&lt;/code&gt;&lt;br&gt;
&lt;code&gt;https://raw.githubusercontent.com/deepzec/Win-PortFwd/master/win-portfwd.ps1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;方法2：使用netsh&lt;/h2&gt;
&lt;h3&gt;开端口,总览,重置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;netsh interface portproxy show all&lt;/code&gt;&lt;br&gt;
&lt;code&gt;netsh interface portproxy add v4tov4 listenaddress=$Lhost listenport=$Lport connectaddress=$Rhost connectport=$Rport&lt;/code&gt;&lt;br&gt;
&lt;code&gt;netsh interface portproxy reset&lt;/code&gt;  &lt;/p&gt;
&lt;h3&gt;开防火墙&lt;/h3&gt;
&lt;h4&gt;Old command:&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;netsh firewall add portopening TCP 80 "Open Port 80"&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;New ~~command~~:&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;netsh advfirewall firewall add rule name= "Open Port 80" dir=in action=allow protocol=TCP localport=80&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;两个方法本质都是netsh.&lt;/p&gt;</content></entry><entry><title>Android tcp &amp; https capture 抓包</title><link href="alan717.github.io/capture.html" rel="alternate"></link><published>2020-08-25T00:00:00+08:00</published><updated>2020-08-25T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-08-25:alan717.github.io/capture.html</id><summary type="html">tcp capture</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;Android 13
tcpdump 
rooted devices.&lt;/p&gt;
&lt;h2&gt;TCP&lt;/h2&gt;
&lt;h3&gt;抓包命令&lt;/h3&gt;
&lt;p&gt;一般手机有tcpdump命令，无需下载
&lt;code&gt;/data/local/tcpdump -i any -p -s 0 -w /sdcard/capture.pcap&lt;/code&gt;  &lt;/p&gt;
&lt;h3&gt;capture.pcap包分析&lt;/h3&gt;
&lt;p&gt;直接拖进wireshark分析.&lt;/p&gt;
&lt;h4&gt;分析细节纪要&lt;/h4&gt;
&lt;p&gt;wireshark 打开对应tcp包的 链路层变成linux cooked capture v1.&lt;/p&gt;
&lt;h5&gt;Linux cooked-mode capture (SLL)&lt;/h5&gt;
&lt;p&gt;为何链路层名称为linux cooked capture？而不是Ethernet Ⅱ
因为包是在linux中使用tcpdump，且指定参数-i any来捕获设备上所有网卡上的包。它会把所有包的以太网头都换成linux cooked capture，wireshark对此解释为虚假的协议。
tcpdump抓包时，如果-i选项指定为一个网卡地址，那么抓取的数据包数据链路层是以太网头部；如果指定any，则以太网头部将被替换为linux cooked capture头部&lt;/p&gt;
&lt;h2&gt;https&lt;/h2&gt;
&lt;p&gt;fiddler 导出证书
&lt;code&gt;openssl x509 -inform DER -in C:\Users\Kian\Desktop\FiddlerRoot.cer -out C:\Users\Kian\Desktop\FiddlerRoot.pem&lt;/code&gt;&lt;br&gt;
&lt;code&gt;openssl x509 -inform PEM -subject_hash -in C:\Users\Kian\Desktop\FiddlerRoot.pem&lt;/code&gt;  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;035f9290
-----BEGIN CERTIFICATE-----
MIIDsjCCApqgAwIBAgIQF05TM2cD64tNXZ9wqO5YuDANBgkqhkiG9w0BAQsFADBn
MSswKQYDVQQLDCJDcmVhdGVkIGJ5IGh0dHA6Ly93d3cuZmlkZGxlcjIuY29tMRUw
EwYDVQQKDAxET19OT1RfVFJVU1QxITAfBgNVBAMMGERPX05PVF9UUlVTVF9GaWRk
bGVyUm9vdDAeFw0yMDExMjQwOTE2MDVaFw0yNDAyMjMwOTE2MDVaMGcxKzApBgNV
BAsMIkNyZWF0ZWQgYnkgaHR0cDovL3d3dy5maWRkbGVyMi5jb20xFTATBgNVBAoM
DERPX05PVF9UUlVTVDEhMB8GA1UEAwwYRE9fTk9UX1RSVVNUX0ZpZGRsZXJSb290
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4k9jH8WVyCzKF/PWL2mN
3228CgqhRBxSuRYUZeOi73d+sRumd3Z2n7uKtUPQTmrWZ34iMLt0fNMn8vliHnnI
F/vc2WDjGBiK2Bwdbe/vlme1MeGSK+VQKiCUQSGWRtG8vN3bRLKkjeWu7UsqZKHv
8MQoXdWUBHgMdSUbCA9RStiaK9oZYlFClWm2lxwLvG2FmkupxQDadBUzYUEdxsfx
VsxglGWpwo+kK3R5ef9dQ68LBzrcImbrClWGYYRQ9hgizJu8uvrmMtTC3eGLhRS0
C8pPpZ47mNE/saEauXyeF8GczfG5lbyJhWP1hXN16AMNJkWTNdGoU4UBmohL6RUw
AQIDAQABo1owWDATBgNVHSUEDDAKBggrBgEFBQcDATASBgNVHRMBAf8ECDAGAQH/
AgEAMB0GA1UdDgQWBBQonuyOhHPvj5K+tL0vA2zVqDp3TDAOBgNVHQ8BAf8EBAMC
AQYwDQYJKoZIhvcNAQELBQADggEBAAEyHBulbUdWIFWuBYOtxQk6Gt9fQ9mI5GF3
jq2qvhK3kBhNveARX2LH20S7BD0KsR++BsDzw0FuHikSqfGtUPiuPN5HPAb8jY2N
GrRdMTnbMEWbmXVHaoXsRTo7YqUjhX/268YDid9UXo6YMGE9S2JkmG+vhGyTUZsd
oUTmgTQ4fzm8WIgfNLxiLsU5H345gwVbLRDAeeavZzneiZWaRDmu3MSLNIkwgFuF
3pDp9nSOncjU9wpkopSOp1X1T10cHWe5M2bNZMBkQGR5b7KmK4QhjhZFtgKJTHh1
KQ3oSWrOun9XpzbCAMfSHzIgC48w/V1+YGR9n5SlY7V73qnMAJU=
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上图输出的 hash 035f9290
因此将 .pem 证书重命名为 e5c3944b.0
手机 magisk 必须要先安装一个模块，如 lsposed
下面步骤可以使用 MT管理器 或者 ADB 命令操作
在手机 /data/adb/modules 目录下随便找一个模块的目录，这里我选 lsposed , 进入此目录
在此目录下创建 system/etc/security/cacerts 目录，将 e5c3944b.0 文件拷贝到新建的这个目录下
最终证书路径为 /data/adb/modules/xxx/system/etc/security/cacerts/e5c3944b.0
重启手机，wifi 界面设置代理 xxx.xxx.xxx.xxx:8888 即可抓包&lt;/p&gt;
&lt;p&gt;Fiddler 方式适合任意抓包软件，只需要将对应证书转换成 xxxxxxxx.0 文件放入 /data/adb/modules/xxx/system/etc/security/cacerts 目录即可&lt;/p&gt;</content></entry><entry><title>gdb调试</title><link href="alan717.github.io/gdb.html" rel="alternate"></link><published>2020-08-13T00:00:00+08:00</published><updated>2020-08-13T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-08-13:alan717.github.io/gdb.html</id><summary type="html">gdb</summary><content type="html">&lt;h2&gt;env&lt;/h2&gt;
&lt;p&gt;android、linux&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不涉及基础命令，基础命令请直接看document.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;核心原理&lt;/h2&gt;
&lt;p&gt;ptrace信号接口.使用ptrace接口和trap信号配合使用.具体实现直接看代码.&lt;/p&gt;
&lt;h2&gt;分析框架&lt;/h2&gt;
&lt;p&gt;主要看gdbserve之间的通信协议。ida 是支持gdb协议的，gdbserver的通信协议很简单主要是明文十六进制传输，在这种情况下，配合qiling和unicorn框架
在load gdbserver二进制之后处理程序逻辑有很大的便利和方便，直接整机的dump，然后进行仿真执行，直接能看到具体的问题点，这些问题点需要想象和经验来判断&lt;br&gt;
判断完成之后进行仿真和bypass操作即可完成处理。&lt;/p&gt;
&lt;h2&gt;调试办法&lt;/h2&gt;
&lt;h3&gt;dump调试&lt;/h3&gt;
&lt;p&gt;直接整进程dump 直接qemu或者是qiling仿真，直接gdb  &lt;code&gt;-s -S&lt;/code&gt;调试。识别到关键的函数和数据会很快解决问题。&lt;/p&gt;
&lt;h3&gt;暂停stop specially process&lt;/h3&gt;
&lt;p&gt;直接发信号暂停整个进程，然后回溯处理。&lt;/p&gt;
&lt;h3&gt;特殊数据处理&lt;/h3&gt;
&lt;p&gt;这种情况属于开发阶段的处理情况，直接查看文档就可以解决。&lt;/p&gt;</content></entry><entry><title>使用dll生成对应的lib文件</title><link href="alan717.github.io/%E4%BD%BF%E7%94%A8dll%E7%94%9F%E6%88%90%E5%AF%B9%E5%BA%94lib%E6%96%87%E4%BB%B6.html" rel="alternate"></link><published>2020-07-03T00:00:00+08:00</published><updated>2020-07-03T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2020-07-03:alan717.github.io/%E4%BD%BF%E7%94%A8dll%E7%94%9F%E6%88%90%E5%AF%B9%E5%BA%94lib%E6%96%87%E4%BB%B6.html</id><summary type="html">使用dll生成对应的lib文件</summary><content type="html">&lt;h1&gt;使用dll生成对应的lib文件&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;有时候没有lib文件，只有头文件，怎么生成lib文件呢~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;导出信息&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dumpbin /exports C:\yourpath\yourlib.dll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出如:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;ordinal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RVA&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001080&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_close&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001120&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_disasm&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001590&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_disasm_ex&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;000015&lt;/span&gt;&lt;span class="n"&gt;A0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_disasm_iter&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001790&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_errno&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;6&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;000017&lt;/span&gt;&lt;span class="n"&gt;A0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_free&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;6&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;000017F&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_group_name&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001810&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_insn_group&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001850&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_insn_name&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mh"&gt;9&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001870&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_malloc&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;11&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;000018F&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_op_count&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00001&lt;/span&gt;&lt;span class="n"&gt;C00&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_op_index&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002050&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_open&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;14&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;000021&lt;/span&gt;&lt;span class="n"&gt;A0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_option&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;000024&lt;/span&gt;&lt;span class="n"&gt;C0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_reg_name&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;000024E0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_reg_read&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;17&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002520&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_reg_write&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;18&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;11&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002560&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_regs_access&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002620&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_strerror&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;20&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002700&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_support&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="mh"&gt;21&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mh"&gt;14&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;00002730&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cs_version&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后复制name
保存一个文件叫&lt;code&gt;lib_name.def&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;EXPORTS
cs_close
cs_disasm
cs_disasm_ex
cs_disasm_iter
cs_errno
cs_free
cs_group_name
cs_insn_group
cs_insn_name
cs_malloc
cs_op_count
cs_op_index
cs_open
cs_option
cs_reg_name
cs_reg_read
cs_reg_write
cs_regs_access
cs_strerror
cs_support
cs_version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后使用lib.exe&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lib.exe  /DEF:C:\Users\Kian\Desktop\capstone.def /OUT:C:\Users\Kian\Desktop\capstone.lib
生成对应的lib文件。
&lt;/p&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Lua-5.1 long string comments分析四</title><link href="alan717.github.io/lua51-longSC.html" rel="alternate"></link><published>2019-09-26T00:00:00+08:00</published><updated>2019-09-26T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-09-26:alan717.github.io/lua51-longSC.html</id><summary type="html">注释和长字符。</summary><content type="html"></content></entry><entry><title>Lua-5.1 varargs分析三</title><link href="alan717.github.io/lua51-varargs.html" rel="alternate"></link><published>2019-09-20T00:00:00+08:00</published><updated>2019-09-20T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-09-20:alan717.github.io/lua51-varargs.html</id><summary type="html">varargs特性.</summary><content type="html"></content></entry><entry><title>Lua-5.1 gc分析二</title><link href="alan717.github.io/lua51-gc.html" rel="alternate"></link><published>2019-09-10T00:00:00+08:00</published><updated>2019-09-10T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-09-10:alan717.github.io/lua51-gc.html</id><summary type="html">garbase collect.</summary><content type="html"></content></entry><entry><title>Lua-5.1 coroutine分析二</title><link href="alan717.github.io/lua51-coroutine.html" rel="alternate"></link><published>2019-08-26T00:00:00+08:00</published><updated>2019-08-26T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-08-26:alan717.github.io/lua51-coroutine.html</id><summary type="html">初步编译器分析</summary><content type="html">&lt;h2&gt;coroutine&lt;/h2&gt;</content></entry><entry><title>Lua-5.1 编译分析一</title><link href="alan717.github.io/lua51.html" rel="alternate"></link><published>2019-08-13T00:00:00+08:00</published><updated>2019-08-13T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-08-13:alan717.github.io/lua51.html</id><summary type="html">初步编译器分析</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;分析lua的很多了，这里记录一下我的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;词法分析&lt;/h2&gt;
&lt;p&gt;lua-5.1词法分析在llex.c中，为了表达状态机lua实现了lexstate来存储使用的数据其中Mbuffer类型的buff每次会情况重置，然后从zio中再读一个字节
赋给current， next()会读一个字符，如图：
&lt;img alt="Image" src="./pic/lua-5.1.1.png"&gt;&lt;br&gt;
前端将文件token化读入，token化
&lt;img alt="Image" src="./pic/lua-5.1.2.png"&gt;&lt;br&gt;
解析变量名luaX_newstring转换成一个tstring存进语义seminfo中，然后返回当前为token_name类型。&lt;/p&gt;
&lt;h3&gt;zio&lt;/h3&gt;
&lt;p&gt;其中zio读取文件到内存中处理,省去频繁文件i/o读增加效率.&lt;/p&gt;
&lt;h3&gt;lookahead&lt;/h3&gt;
&lt;h2&gt;字节码转换指令生成&lt;/h2&gt;
&lt;p&gt;例如：
&lt;code&gt;helloworld.lua&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-- the first program in every language

io.write(&amp;quot;Hello world, from &amp;quot;,_VERSION,&amp;quot;!\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先读的- 然后判断第二个token是不是‘-’如果是则为注释。
然后根据chunk处理&lt;br&gt;
&lt;code&gt;/* chunk -&amp;gt; { stat [`;'] } */&lt;/code&gt;&lt;br&gt;
然后展开为stat：  &lt;br&gt;
&lt;code&gt;/* stat -&amp;gt; func | assignment */&lt;/code&gt;&lt;br&gt;
自上而下展开，主表达式primaryexp：  &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; /* primaryexp -&amp;gt;
        prefixexp { `.&amp;#39; NAME | `[&amp;#39; exp `]&amp;#39; | `:&amp;#39; NAME funcargs | funcargs } */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后根据 . token展开：field 展开-》luaK_dischargevars
来判断变量类型：展开成lua5.1字节码存储起来成表达式信息。
如图：
&lt;img alt="Image" src="./pic/lua-5.1.3.png"&gt;&lt;br&gt;
然后读io 为token_name类型，则认为时global变VGLOBAL，
&lt;img alt="Image" src="./pic/4.png"&gt;&lt;br&gt;
然后展开.write函数.
再到primaryexp函数解析函数（）调用:
&lt;img alt="Image" src="./pic/5.png"&gt;&lt;br&gt;
生成调用函数的call 寄存器保存指令，然后 保存函数参数到hash表，然后保存栈，然后括号匹配.
完成后下一行语句。
&lt;img alt="Image" src="./pic/6.png"&gt;&lt;br&gt;
整体自上而下展开。&lt;/p&gt;
&lt;h2&gt;后端执行&lt;/h2&gt;
&lt;p&gt;后端执行在执行在vm中执行，在&lt;code&gt;\src\lvm.c&lt;/code&gt;是vm代码。luaV_execute执行指令。这里执行的指令已经是翻译好的字节码了。&lt;/p&gt;
&lt;h2&gt;ZJ&lt;/h2&gt;
&lt;p&gt;没有过多的剖析代码的细节，只分析总体大纲，在基础上有清楚认识之后开始单独分析。下面二、三将分析具体的实现细节。&lt;/p&gt;</content></entry><entry><title>Base64算法分析</title><link href="alan717.github.io/base64%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93.html" rel="alternate"></link><published>2019-04-23T00:00:00+08:00</published><updated>2019-04-23T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-04-23:alan717.github.io/base64%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93.html</id><summary type="html">A brief description of base64 algorithm.</summary><content type="html">&lt;h1&gt;base64&lt;/h1&gt;
&lt;h2&gt;数学分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;wiki描述: Base64（基底64）是一种基于64个可打印字符来表示二进制数据的表示方法
用64个符号表示二进制，求一下表示64个字符需要多少位用log2(64)=6,需要六位，而二进制一个字节8位，最大公约数
为24为三个字节，表示为4个字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法如下：&lt;/p&gt;</content></entry><entry><title>aboot分析一</title><link href="alan717.github.io/aboot.html" rel="alternate"></link><published>2019-03-05T00:00:00+08:00</published><updated>2019-03-05T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-03-05:alan717.github.io/aboot.html</id><summary type="html">分析nexus5的android boot.</summary><content type="html">&lt;h3&gt;前提&lt;/h3&gt;
&lt;p&gt;手里有一个nexus5手机，想分析研究一下。&lt;/p&gt;
&lt;h3&gt;实践&lt;/h3&gt;
&lt;h4&gt;准备&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;nexus5手机&lt;/li&gt;
&lt;li&gt;电脑&lt;/li&gt;
&lt;li&gt;系统版本:mra58k&lt;/li&gt;
&lt;li&gt;软件：ida free,010editor&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;load bin.&lt;/h4&gt;
&lt;p&gt;aboot来自于手机包中,用imjtool提取bootloader-hammerhead-hhz12k.img文件,得到单独的aboot文件。这个文件并不是直接来自于存储芯片，而是需要fastboot工具刷写，自然而然这个文件是有文件头的，
文件头格式的定位需要逆向分析来实现，首先确定的是arm芯片的exception vector 一般追踪这个向量表则不难定位到文件的code segment，exception vector
有个特征是 b 0x123456,其中b指令就是0xEA,这个指令后边的立即数就是距离当前指令的偏移;还有一种方式就是直接在源代码中查找,这个源代码不用最新版也可以确定一些特征,aboot用的就是LK。
&lt;img alt="Image" src="./pic/2.png"&gt;
&lt;img alt="Image" src="./pic/1.png"&gt;&lt;/p&gt;
&lt;p&gt;除此之外要让逆向工具识别二进制，需要知道二进制的load base address. 在arm下一些指令如ldr是hard code读绝对地址字符串，根据这个特征就可以知道
load base address是多少了。一般会拿到头部的两个字节，然后根据头部的两个字节去在文件头中找到对应的数据结构。
当然这要保证拿到的文件是raw data,而非加密的文件。&lt;/p&gt;
&lt;h4&gt;除此之外&lt;/h4&gt;
&lt;p&gt;除此之外还有证书的部分，这部分的数据，一般在文件头前边或者文件的末尾，这个根据LK的源码或者是分析aboot中的逻辑可以判断出来位置和大小，然后在文件头中找到对应。
本章完.&lt;/p&gt;
&lt;h4&gt;参考&lt;/h4&gt;
&lt;p&gt;[1].http://www.newandroidbook.com/Articles/aboot.html&lt;/p&gt;</content></entry><entry><title>My First Document</title><link href="alan717.github.io/Hello_Blog.html" rel="alternate"></link><published>2019-01-23T00:00:00+08:00</published><updated>2019-01-23T00:00:00+08:00</updated><author><name>LK.</name></author><id>tag:None,2019-01-23:alan717.github.io/Hello_Blog.html</id><summary type="html">A brief description of my first document.</summary><content type="html">&lt;h2&gt;topic&lt;/h2&gt;
&lt;p&gt;尝试使用markdown来写一些blog，把原本网站的内容迁移过来。然后在这里记录一下，制作blog时遇到的问题。
谢谢&lt;/p&gt;
&lt;h2&gt;网页生成&lt;/h2&gt;
&lt;p&gt;网页根据templates中的base.html模板进行填充,文章|内容填充在&lt;main&gt;标签之内,具体的网页头都在这个之中。&lt;/p&gt;
&lt;h2&gt;css&lt;/h2&gt;
&lt;h3&gt;display:flex,block区别&lt;/h3&gt;
&lt;h3&gt;padding&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ex:
     padding: 0rem 0.2rem;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个参数为上下,第二个为左右.&lt;/p&gt;
&lt;h3&gt;@media&lt;/h3&gt;
&lt;p&gt;判断设备参数.&lt;/p&gt;
&lt;h3&gt;em&lt;/h3&gt;
&lt;p&gt;em：相對單位，每個子元素透過「倍數」乘以父元素的 px 值。&lt;/p&gt;</content></entry></feed>